Container Runtimes in Kubernetes (v1.32 and beyond)
🚨 Important Note

    Dockershim has been removed starting from Kubernetes v1.24.

    You cannot use Docker directly anymore like before.

    Kubernetes now requires a container runtime that supports the CRI (Container Runtime Interface).

🧱 What is a Container Runtime?

A container runtime is software installed on each node of a Kubernetes cluster. It is responsible for:

    Running containers.

    Interacting with the kubelet to manage pods.

✅ Supported Container Runtimes (Post Dockershim)

    containerd – Lightweight and widely used.

    CRI-O – Designed specifically for Kubernetes.

    Docker Engine (Only via cri-dockerd adapter now)

    Mirantis Container Runtime (MCR) – Commercial version, uses cri-dockerd as well.

⚙️ CRI (Container Runtime Interface)

    It’s an API that container runtimes must support to talk with Kubernetes.

    Kubernetes 1.32 requires runtimes to support CRI v1.

        Older versions fallback to v1alpha2 (deprecated).

    Make sure your runtime supports CRI v1 for compatibility.

🛜 Network Configuration (Important for Pods to Communicate)

By default, Linux blocks IPv4 forwarding.

You must enable it manually if your CNI (Container Network Interface) plugin doesn’t do it automatically.

How to enable IPv4 forwarding:

```cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.ipv4.ip_forward = 1
EOF
sudo sysctl --system
sysctl net.ipv4.ip_forward   # Should show 1
```

🧩 Cgroup Drivers – Critical for Resource Management

Cgroups (Control Groups) manage CPU/memory resources for containers.
Both the kubelet and container runtime must use the SAME cgroup driver.
🔘 Two Types of Cgroup Drivers:

    cgroupfs – Default in kubelet.

    systemd – Recommended when using systemd init system (most Linux distros use it).

⚠️ Why Matching Cgroup Drivers is Important

If kubelet uses cgroupfs and the system uses systemd, it causes resource instability (especially under load).

Solution: Use systemd as the cgroup driver in both:

    kubelet

    container runtime

✅ Example kubelet configuration:

```apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd
```
🛑 WARNING:

If a node has already joined the cluster and created pods, don’t just change the cgroup driver.
➡️ Best practice: Recreate the node with the new configuration.
🔧 Runtime-Specific Configuration Examples
1. containerd

Installation:

    Follow containerd installation guide.

    Config file: /etc/containerd/config.toml

    Default CRI socket: /run/containerd/containerd.sock

To enable systemd cgroup driver:

[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
  SystemdCgroup = true

To override pause image:

[plugins."io.containerd.grpc.v1.cri"]
  sandbox_image = "registry.k8s.io/pause:3.10"

Commands:

containerd config default > /etc/containerd/config.toml
sudo systemctl restart containerd

2. CRI-O

    Default CRI socket: /var/run/crio/crio.sock

    Uses systemd cgroup driver by default (✅ good).

To switch to cgroupfs (not recommended unless needed):

[crio.runtime]
conmon_cgroup = "pod"
cgroup_manager = "cgroupfs"

Override pause image:

[crio.image]
pause_image="registry.k8s.io/pause:3.10"

Apply config changes:

systemctl reload crio

3. Docker Engine (with cri-dockerd)

    🛑 Docker doesn’t support CRI.
    ✅ Use cri-dockerd (adapter to bridge Docker and Kubernetes).

    CRI socket: /run/cri-dockerd.sock

Steps:

    Install Docker.

    Install cri-dockerd from its GitHub repo.

    Configure kubelet to use cri-dockerd.

Override pause image: Use command line argument:

--pod-infra-container-image=registry.k8s.io/pause:3.10

4. Mirantis Container Runtime (MCR)

    Commercial alternative to Docker Enterprise Edition.

    Uses cri-dockerd like Docker.

    Refer to MCR Deployment Guide for setup.

📌 Key Reminders for Exam

    Post v1.24: Dockershim is removed → use containerd, CRI-O, or Docker with cri-dockerd.

    Container runtimes must support CRI v1 (esp. from v1.26+).

    IPv4 forwarding must be enabled unless your CNI does it.

    Always match the cgroup driver (systemd is preferred).

    If changing cgroup driver → best to recreate the node.

    Configure the pause image (sandbox_image) in runtime config.

📚 Easy Example Summary

Runtime	Default CRI Socket	Cgroup Driver	Pause Image Config

containerd	/run/containerd/containerd.sock	systemd	config.toml → sandbox_image = ...

CRI-O	/var/run/crio/crio.sock	systemd	crio.conf → pause_image = ...

Docker Engine	/run/cri-dockerd.sock	Manual	via --pod-infra-container-image=... argument

MCR	Check cri-docker.socket	Manual	Uses cri-dockerd like Docker
